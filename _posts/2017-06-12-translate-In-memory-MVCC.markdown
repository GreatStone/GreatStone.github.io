---
layout: post
title:  "翻译 《An Empirical Evaluation of In-Memory Multi-Version Concurrency Contorl》"
date:   2017/06/05 11:48:00 +0800
categories: Daily
---


工作中对于MVCC接触的已经比较多了，但是依然对MVCC的实现细节以及设计思路没有比较清晰的认知，因此在这里翻译一篇关于内存介质的MVCC的整体介绍，也作为笔记。
<br/>

*****
<br/>
<br/>
## 摘要
   MVCC（Multi-version concurrency control多版本并发控制）是现代数据库管理系统最流行的事务管理方式。尽管早在19世纪70年代就已经发明了MVCC技术，但它仍然被近十年主流的数据库系统广泛使用。MVCC通过维护多个版本的数据，一定程度上，在不影响事务的可串行性的同时提升了数据库的并发度。然而在多核的内存操作环境下，拓展MVCC并不是一件容易的事情：当有大量线程在并行运行时，线程间同步的开销可能足以抵消MVCC带来的并发优化。

   为了了解现代硬件环境下MVCC机制如何处理事务，我们从四个主要维度进行了广泛的调研：并发控制协议、版本存储、垃圾回收以及索引管理。我们用了以上技术的最先进方法实现了内存数据库，并且用OLTP的负载来进行评测。我们分析出了各种设计上的取舍导致的关键瓶颈。

## 1. 简介
   多核的出现带来了计算机架构的进化，内存数据库系统在不牺牲可串行性的前提下，实现了高效的事务管理机制。近十年，数据库系统中发展起来的最流行的技术就是MVCC。为了并行地处理同一个对象，数据库同时维护这一个逻辑对象的多个物理版本，这就是MVCC的基本思想。这个对象可以是任意粒度的，但是几乎所有的MVCC数据库都使用了元组（tuple）粒度来进行控制，因为这在多版本追踪和多并发之间取得了比较平衡的效果。多版本允许只读事务获取较为旧的数据，而不必阻止同时执行的读写事务产生同一数据的新版本。和单版本系统比较起来，事务总是在更新的时候用较新的数据覆盖原有的元组。

   有趣的是，数据库使用MVCC并不是一个最近发展起来的趋势。MVCC在1979年第一次出现在学术论文当中，1981年的InterBase DBMS第一个实现了MVCC（现已成为开源项目FireBird）。此外在许多面向磁盘的数据库当中也广泛使用了MVCC，比如Oracle（1984年），Postgres（1985年）以及MySQL的InnoDB引擎（2001年）。但是同时代的也有大量数据库使用单版本管理（如IBM DB2、Sybase），几乎所有新的支持事务的数据库都支持MVCC，而避免了这种单版本管理。不论是商业系统（例如 Microsoft Hekaton、SAP HANA、MemSQL、NuoDB）还是学术系统（例如 HYRISE、HyPer）都是如此。

   尽管新生的这些系统都采用了MVCC，但并没有一个“标准”实现。在不同的取舍以及性能表现下，有许多设计上的选择。目今为止，对现代数据库系统环境下的MVCC，还没有详尽的评测。最新的比较详尽的研究，是在1980年代，然而这项研究使用了面向磁盘存储的数据库系统，并且在单核CPU上运行模拟负载。在古老的磁盘数据库上的设计取舍，对于一个运行在多核CPU的内存数据库来说是不合适的。因此，最近的无锁的、可串行化的并发控制的趋势并不能通过以前的这些研究反映出来，内存存储以及混合的负载也是一样。

   本文中，我们研究了MVCC数据库系统中几个关键的事务管理设计：(1) 并发控制协议，(2)版本存储，(3)垃圾回收，(4)索引管理。对于每个主题，我们都描述了在内存数据库上最先进的实现以及他们分别的设计权衡。也同样突出了如何避免为更大线程数量以及更复杂负载而扩展的问题。作为研究的一部分，我们在Peloton内存数据库当中实现了所有这些方法。这使得我们可以用统一的平台来比较这些实现，而不必考虑其他架构因素带来的问题。我们在一台有40核的机器上部署了Peloton，并且使用两个OLTP场景测试来进行评测。我们分析了对不同实现的加压方案并且讨论了减轻他们的方案。

## 2. 背景
   我们首先对MVCC进行高度概括式的概览，并讨论DBMS用来进行事务追踪以及版本信息维护的元信息。

### 2.1
   事务管理系统允许用户在保持隔离性的同时，以并发的方式访问数据库。这保证了数据库系统的原子性和隔离性。

   多版本系统有很多优势是对现代数据库应用非常重要的。最重要的是，多版本系统提供了比单版本系统更高的并发度。比如，一个采用了MVCC的数据库系统，会允许事务读取一个值的比较旧的版本，与此同时，另外一个事务还可以更新这个值。这对于在执行读写事务(read-write transaction)的同时做只读查询的场景非常重要。如果DBMS永远不删除旧版本数据，这个系统就可以支持“时间序列”操作。如果某些数据在历史时间点上存在过，则这一操作允许应用程序访问这一数据的连续的快照（consistent snapshot）

   以上的好处使得MVCC成为了近年来新的DBMS的主要实现手段。表1给出了近三十年的MVCC实现的总结。但是在DBMS当中实现多版本系统的方式非常多样，每种各有额外的计算以及存储开销。这些设计上的取舍是相互依存的。因此，要讨论哪一种实现更好以及为什么，这不是一件容易的事情。尤其是对于内存型数据库，摆脱了磁盘这一主要瓶颈的数据库技术。

   接下来的章节内，我们会讨论这些设计方案在实现细节以及性能权衡上（trade off）的比较。我们将在第七节给出一个全面的评测。本文中仅考虑可串行化事务执行。尽管日志和恢复也是DBMS架构当中非常重要的部分，但是我们在这篇文章中不涉及这些部分，因为这些部分和单版本系统并没有什么不同，并且内存型数据库的日志系统已经在别的地方被覆盖。


||年份|协议|存储介质类型|垃圾回收|索引类型|
|:--:|:--:|:--:|:--:|:--:|:--:|
|Oracle|1984|MV2PL|Delta|Tuple-level (VAC)|Logical Pointers (TupleId)|
|Postgres|1985|MV2PL/SSI|Append-only (O2N)|Tuple-level (VAC)|Physical Pointers|
|MySQL-InnoDB|2001| MV2PL |Delta| Tuple-level (VAC)| Logical Pointers (PKey)|
|HYRISE|2010|MVOCC|Append-only (N2O)| - |Physical Pointers|
|Hekaton| 2011| MVOCC| Append-only (O2N)| Tuple-level (COOP)| Physical Pointers|
|MemSQL| 2012| MVOCC| Append-only (N2O)| Tuple-level (VAC)| Physical Pointers|
|SAP HANA| 2012| MV2PL| Time-travel| Hybrid| Logical Pointers (TupleId)|
|NuoDB| 2013| MV2PL| Append-only (N2O)| Tuple-level (VAC)| Logical Pointers (PKey)|
|HyPer |2015 |MVOCC |Delta |Transaction-level |Logical Pointers (TupleId)|

##### 表-1 MVCC实现
##### 商用以及研究用MVCC数据库的设计决策总结。表中年份指对应系统（除Oracle以外）第一次发布的时间。表中Oracle的年份属性，是指它第一次采用MVCC方案的年份。除了Oracle、MySQL以及Postgres以外，所有系统的主存都是内存。

### 2.2 DBMS元数据
无论数据库采用了何种实现，都会用到几种常见的元数据，这些元数据被DBMS用来处理事务和数据库元组（database tuple）。

事务： DBMS为事务T分配了一个唯一的、单调递增的时间戳来作为这些事务提交到系统内的标识（T<sub>id</sub>）。并发控制协议使用这个标志来标记这一事务所使用到的元组。某些协议也使用它来作为事务串行化的顺序。

![image01]({{site.url}}/assets/MVCC-figure1.png)
#### 图-1 元组格式 - 元组的物理版本的基本布局

元组：如图1所示，每一个物理版本在头部有四个元数据字段，被DBMS用来协调事务的并发执行（接下来的章节中所要讨论的某些协议当中会包含其他字段）。txn-id字段作为事务的写锁使用。任意一个未被写锁保护的元组都需要将这一字段设置为0。大多数DBMS使用了一个64位的txn-id，以便于可以使用单次的“比较并交换”（CaS）指令来原子地更新这一个值。如果标识为T<sub>id</sub>的事务T想要更新元组A，那么DBMS会检查A的txn-id字段是否为0。如果检查成功，那么DBMS会使用CaS指令来将txn-id设置为T<sub>id</sub>。

任何想要更新A的事务，都会在txn-id不为0且不和事务自身的T<sub>id</sub>相等的情况下被终止。接下来的两个元数据字段是begin-ts和end-ts，他们是两个时间戳，用来表示这个元组版本的生命周期。这些字段的初始值都是0。当元组被事务删除的时候，DBMS会把begin-ts设置为无限大（INF）。最后一个字段是pointer，存储了相邻的（前一个或者后一个）版本（如果存在的话）。

## 3 并发控制协议

