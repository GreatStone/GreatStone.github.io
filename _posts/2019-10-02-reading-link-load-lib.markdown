---
layout: post
title:  "《程序员的自我修养——链接、装载与库》读书笔记"
date:   2019/10/02 20:21:00 +0800
categories: Note
---

<style type="text/css">p{text-indent:2em}</style>
<style type="text/css">
.post-content h5 { font-size: 18px; }
</style>

<script src="/assets/mermaid.min.js"></script>

# 《程序员的自我修养——链接、装载与库》读书笔记

*TOC
{:toc}

## 温故而知新

### 操作系统做什么
* CPU调度，在多个任务之间进行协调。演进过程：多道-->分时-->非抢占-->抢占
* 提供设备的管理和抽象。操作系统+硬件驱动共同完成

### 内存管理机制
* 地址空间隔离。物理内存空间和虚拟内存空间相映射，进程间做到隔离。分段：不同进程的内存映射到不同的物理空间
* 提升内存使用效率。 分页：将内存划分成等大的不连续小块，不用让一整段内存连续分配（解决分段的不足）

### 线程调度
线程可以被称为轻量级进程，程序执行流最小单元。
线程组成：线程ID、当前指令指针、寄存器集合、堆栈、etc

* 线程间共享：全局变量、堆数据、静态变量、程序代码、文件描述符
* 线程私有：局部变量、函数参数、TLS数据

线程调度的三种常见状态：Running/Ready/Waiting

线程调度的两个基本元素：优先级调度&轮转法

改变优先级的三种方法：
* 用户指定
* 根据进入等待状态的频繁程度调整
* 长时间得不到执行而提升优先级

非抢占的常见度让点：
* 试图等待IO等事件
* 主动放弃时间片

Linux所有执行实体都是Task，多个任务之间可以选择共享内存空间，共享了同一个的多个任务就构成一个进程，里面的任务就是线程。

fork产生新任务非常快，和原来的任务共享一个写时复制的内存空间。clone会新建一个线程，从指定资源开始执行。

单指令操作被称为原子操作，不会被打断。如果要保证复杂结构的原子性，原子操作无法支持，需要用锁。

#### 几种同步方法

##### 信号量
二元信号量最简单的一种锁，只有占用和非占用两种状态，适合只能被唯一一个线程独占访问的资源。
多元信号量（初始值为N的）可以允许N个线程并发访问资源。

##### 互斥量
和信号量非常类似，但是不允许一个线程借用后，另外一个线程进行释放。

##### 临界区
和互斥量类似。但仅限于本进程，其他进程无法获取。

##### 读写锁
两种获取方式：共享/独占。自由状态下两种都能成功，共享状态允许共享，互斥状态都不允许。

##### 条件变量
类似于一个栅栏，唤醒满足条件的线程执行。

#### 多线程特殊优化

可重入的特征：
* 不使用静态/全局的非const变量
* 不返回任何静态/全局非const变量指针
* 仅依赖于调用方参数
* 不依赖任何单个资源的锁
* 不调用任何不可重入函数

violate的作用：
* 阻止编译器将变量缓存到寄存器不写回
* 阻止编译器调整volatile变量的指令顺序

barrier作用：组织指令换序穿过这条指令。

#### 三种线程模型
* 一对一模型。线程数受内核限制；内核线程上下文切换开销大。
* 多对一模型。一个用户态线程阻塞会影响所有线程。处理器核数增多不能提升性能；上下文切换得到提升&线程数量无限制
* 多对多模型。结合了以上两种特点。多处理器带来的提升程度没有一对一模型大。

## 编译和链接

编译的步骤：
* 预处理
* 编译
* 汇编
* 链接

### 编译器前端
* 词法分析：通过有限状态机将源代码程序分析成连续的符号
* 语法分析：通过上下文无关文法生成语法树。
* 语义分析：编译器分析静态语义；运行时分析动态语义。静态语义通常包含声明和类型的匹配、类型的转换。完成后语法树的表达式都被标识了类型。
* 中间语言生成：将语法树生成中间代码，很接近目标代码，一般和目标机器和运行时环境无关。常见的有三地址码和P-代码。

### 编译器后端
* 代码生成
* 目标代码优化

### 链接
最早来自于汇编器的功能，汇编器负责将符号转换成地址，不需要增加代码之后手动更新变量/函数地址。这一功能称为“重定位”
链接的主要过程：地址和空间分配、符号决议、重定位

## 目标文件有什么

PE和ELF都是COFF的变种，目标文件和可执行文件的格式几乎是一样的。静态链接库稍有不同，是把很多目标文件打包成一个，加上一些索引。

* 程序源码编译后的机器指令通常放在代码段，一般命名".code"或者".text"
* 全局变量和局部静态数据通常在数据段，命名一般为".data"
* 未初始化的全局变量和局部默认静态变量存在".bss"段里。因为默认值全部为0，不需要在.data当中分配空间。.bss为未初始化的全局变量和局部静态变量预留位置，在文件中不占用空间。


数据和指令段分开存储的好处：

* 指令和数据分别映射到两个虚存区域，数据可读写，程序只读，可以分别设置权限，防止程序指令被改写
* CPU缓存一般设计为数据缓存和指令缓存分离，所以程序指令和数据分开存放对CPU的缓存命中提高有好处
* 系统中运行大量同一份代码的副本时，共享指令段可以节省大量空间

NOTE： **全局的未初始化变量不一定会被存放在bss段，有可能只预留一个未定义的全局变量符号，最终链接为可执行文件时再在.bss分配空间，原因和COMMON块机制有关（跨模块决议符号代表的变量实际大小）；初始化为0的静态变量视同未初始化，一样放在.bss段**

### ELF文件结构

| ELF Header |
|:--:|
|.text|
|.data|
|.bss|
|... 其他段|
| Section header Table(段表) |
|String Tables(字符串常量表)|
|Symbol Tables(符号表)|
|...|

#### 文件头
一些关于目标平台的描述：包含Magic number，字节长度、数据存储方式、版本、运行平台、ABI版本、ELF重定位类型、硬件平台、硬件平台版本、入口地址、程序头入口和长度、段表位置和长度以及段的数量等等。

#### 段表
保存了各个段的基本属性。包含了段类型、名称以及加载方式等等关于段本身的信息。

#### 重定位表
段表类型为SHT_REL的段。对于每个需要重定位的代码段或者数据段，都有一个相应的重定位表。

#### 字符串表
托管所有ELF当中字符串常量的buffer。

### 符号

每个定义的符号有一个对应的值，称为符号值。

符号有以下几种：
* 定义在本目标文件的全局符号
* 本目标文件中引用的全局符号，且没有定义在本目标文件中。称之为外部符号
* 段名。它的值是这个段的起始地址
* 局部符号
* 行号


#### 符号表结构

```
typedef struct
{
  Elf32_Word    st_name;                /* 符号名 (字符串表下标) */
  Elf32_Addr    st_value;               /* 符号值 */
  Elf32_Word    st_size;                /* 符号大小 */
  unsigned char st_info;                /* 符号类型&绑定信息 */
  unsigned char st_other;               /* 是否可见 */
  Elf32_Section st_shndx;               /* 符号所在段 */
} Elf32_Sym;
```

绑定信息：全局/局部/弱引用

符号类型：NOTYPE(未知)/OBJECT(数据)/FUNC(可执行)/SECTION(段)/FILE(文件名)

符号所在段：
* SHN_UNDEF=0     未定义的符号
* SHN_ABS=0xfff1  包含了一个绝对值
* SHN_COMMON      COMMON块类型

特殊符号则被定义在ld链接器的链接脚本当中

#### 符号修饰
函数签名包含了参数类型、所在类、命名空间和其他信息，用于识别不同的函数，c++有一套修饰方法进行映射。变量的类型并不加入到符号当中


#### 强弱符号

* 强符号不允许多次定义，会报重复定义错误
* 如果有一个强符号多个弱符号，选择强符号
* 如果所有符号都是弱符号，选择其中占用空间最大的一个

#### 强弱饮用

在链接成可执行文件过程中必须被正确决议。弱引用在gcc当中可以使用__attribute__((weakref))来指定，弱引用缺少定义不会报错。

## 静态链接

### 空间与地址分配

由于每个段都需要有一定的地址和空间对齐要求，直接将多个文件的所有段叠加非常浪费空间。

一般采用相似段合并的方法进行归并后排布。

两步链接方式：
* 空间与地址分配：扫描输入获得所有段信息，收集符号定义和引用到全局符号表。合并段，计算合并后的长度和位置，生成映射关系。
* 符号解析与重定位


ELF中保留了重定位表来保存这些（哪些指令要调整、指令的哪些部分要调整、如何调整，etc.）与重定位相关的信息。每个要被重定位的ELF段都有一个对应的重定位表，一个表往往就是ELF中的一个段。

重定位表结构
```
typedef struct
{
  Elf32_Addr    r_offset;               /* 地址 */
  Elf32_Word    r_info;                 /* 重定位类型和符号下标 */
} Elf32_Rel;
```

重定位类型信息一般和具体的硬件平台相关。

COMMON块：
来源于Fortran，需要程序员事先声明需要使用的临时空间大小，如果多个文件的COMMON块空间大小不一致的时候，使用最大的一个。COMMON块存在的根本原因在于链接器不支持符号类型，无法判断各个符号的类型是否一致。也因此，未初始化的全局变量不能像未初始化的局部变量一样放在.bss，而是记作COMMON类型变量，因为其最终大小未知。

### c++相关

消除重复代码的原因：
* 减少空间浪费。 模板带来的空间膨胀非常大
* 同一个函数的指针会不相等，需要消除歧义
* 多个相同代码的多副本会降低cache命中率

解决重复代码方法：将每个模板的实例代码都单独放在一个段里，每个段只包含一个模板实例。生成Link Once的段，最终连接过程区分相同的模板实例段，合并入最终的代码段。

c++的全局构造和析构：
ELF定义了两个特殊的段.init和.fini，.init在main调用之前做初始化工作，main函数正常退出时，glibc执行.fini中的代码。

静态库可以看作一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。collect2是对ld链接器的一个封装，主要是收集所有与程序初始化相关的信息并且构造初始化的结构。

控制链接过程的三种方法：
* 指定链接器命令行参数
* 将链接指令存放在目标文件里面，编译器常会用这种方式
* 使用链接控制脚本

## 可执行文件的装载与进程

程序是静态概念，是一些预先编译好的指令和数据集合的一个文件。进程则是动态概念，是程序运行时的一个过程。每个程序运行起来之后拥有自己独立的虚拟地址空间。

两种动态装载方法：
* 覆盖装入：现在几乎被淘汰；多个模块情况下，程序员手动将模块按照他们之间的调用依赖关系组织成树状结构。某一个模块被调用时，调用路径上的所有模块都必须在内存中，禁止跨树间调用。
* 页映射：虚拟存储机制的一部分。数据和指令按照页为单位划分，后面的操作单位都是页。

从操作系统角度来看，一个进程最关键的特征是他拥有独立的虚拟地址空间。初始化进程需要所三件事：
* 创建一个独立的虚拟地址空间
* 读取可执行文件头，建立虚拟空间和可执行文件的映射关系
* 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行

创建虚拟空间实际上是创建映射函数所需要的相应的数据结构。建立虚拟空间和可执行文件的映射关系当程序发生页错误时，操作系统从物理内存中分配一个物理页进行映射。

当以上步骤完成后，CPU打算执行指令时，发现当前页面是个空页面，于是产生一个页错误，将控制权交给操作系统，操作系统专门的页错误处理程序来处理这种情况。

在将目标文件链接成可执行文件的时候，链接器会尽量把相同权限属性的段分配在同一空间。

ELF可执行文件中有一个专门的数据结构叫做程序头表，用来保存Segment信息。

在操作系统中，VMA除了被用来映射可执行文件中的各个Segment之外，还有其他作用，比如管理堆栈空间。有一个特殊的VMA叫做vdso，进程可以通过访问这个VMA来和内核进行一些通信。

进入execve系统调用之后，Linux内核开始进行真正的装载工作
* 首先读取前128个字节，判断执行方式（ELF/python/shell/etc.）
* 检查ELF有效性
* 读取动态链接的.interp段，设置动态链接器路径
* 根据程序头表描述，对ELF文件各段进行映射
* 初始化ELF进程环境，各个寄存器等。
* 将系统调用的返回地址修改成ELF可执行文件的入口点。

## 动态链接

动态链接的基本思想：
* 把链接这个过程推迟到了运行时再执行

动态链接解决的问题：
* 节约空间和内存浪费，不重复存储
* 动态无须重新编译的发布
* 可以在运行时选择加载模块，插件机制

链接器的链接过程需要动态库本身的原因在于，需要通过.so文件获取完整的符号信息，而不仅仅是符号引用信息。

动态连接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行程序之前，首先会把控制权交给动态链接器，由他完成所有的动态链接工作以后再把控制权交给程序来运行。共享对象的最终装载地址在编译时不是确定的。而是装载时，装载器根据当前地址空间的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

可执行文件往往是第一个被加载的文件，可以选一个固定空闲的地址加载，因此可以确定自己在进程虚拟空间中的起始位置。而共享对象不能假设自己在进程虚拟地址空间中的位置。

### 装载时重定位
类似于链接时重定位，可以在装载时进行重定位，带来的问题：由于装载时重定位需要修改指令，所以无法做到同一份指令被多个进程共享。
### 地址无关代码

模块间访问比模块内访问要麻烦一些，ELF的做法是在数据段里面建立一个指向这些和模块装载地址有关的变量的指针数组，称为全局偏移表（GOT），需要这些全局变量时，可以通过GOT中相应的项间接引用。

|  | 指令跳转/调用 | 数据访问 |
|:-- |:--:|:--:|
|模块内部|相对跳转/调用| 相对地址访问|
|模块外部|间接跳转/调用(GOT)|间接访问(GOT)|

### PLT
ELF采用一种叫做延迟绑定的做法，基本思想是“函数第一次被用到时候才进行绑定，如果没有用到则不绑定”。加一次间接跳转，调用函数并不直接通过GOT跳转，而是通过一个叫做PLT项的结构进行跳转。

### 相关结构

.interp段： ELF可执行文件决定使用哪一个动态链接器
.dynamic段：保存的信息类似于ELF文件头，保存了动态链接相关的信息
.dynsym动态符号表：很多时候动态链接的模块同时有.dynsym和.symtab，.symtab保留了所有的符号，.dynsym只有动态符号。
动态链接重定位表
动态链接进程堆栈初始化信息：关于文件句柄、镜像、入口地址等等信息

#### 动态链接实现

在动态链接器的自举代码中，除了不可以使用全局变量和静态变量之外，甚至不能调用函数，即动态连接器本身的函数也不能调用。

在.dynamic段里面指定了可执行文件/共享对象所依赖的共享对象。链接器通过广度优先搜索进行加载。

动态链接器本身应该是静态链接的，不能依赖于其他共享对象。动态链接器本身可以不是PIC的，但是使用PIC可以免去在自举过程中处理重定位的问题。

dlopen/dlsym...这一组调用可以在运行过程中加载动态库，在动态链接过程中，如果有多个同名符号冲突时，先装入的符号优先，这种优先级方式被称为装载序列。

## Linux共享库的组织

共享库兼容讨论的接口是ABI，C语言共享库ABI的改变行为有以下几种：
* 导出函数的行为发生改变
* 删除导出函数
* 导出数据的结构发生变化
* 导出函数的接口发生变化

共享库版本命名：
* 主版本号：重大升级，不同主版本号之间不兼容
* 次版本号：增量升级，增加新的接口符号，保持原来的符号不变
* 发布版本号：不更改接口

SO-NAME是共享库的文件名去掉次版本号和发布版本号。

为了解决次版本号交会问题，提出方案**基于符号的版本机制**，基本思路是让每个导出和导入的符号都有一个相关联的版本号，类似于名称修饰的做法。

NOTE：程序里面记录的不是构建时共享库中版本最新的符号集合，而是程序所依赖的集合中版本号最小的那一个。

GCC允许使用一个叫做".symver"的指令来指定符号版本；可以让多个版本的同一个符号存在于一个共享库中。

### 共享库查找过程

* 如果.dynamic段指定了查找的绝对路径，那么ld就按照这个路径来查找
* 从LD_LIBRARY_PATH当中指定的目录进行查找
* 从/etc/ld.so.conf指定的目录当中查找
* 从/lib、/usr/lib当中查找动态库

由于有全局符号介入这个机制的存在，LD_PRELOAD指定的共享库里面的全局符号会覆盖后面加载的同名全局符号，可以让我们覆写标准库中的某几个函数而不影响其他，对于程序的调试非常有用

链接器"-rpath"选项可以指定链接产生的目标程序的共享库查找路径

GCC提供了共享库的构造函数，声明时加上"__attribute__((constructor))"的属性，即指定该函数为共享库构造函数。这种函数会在main执行前执行。如果用dlopen打开共享库，构造函数会在dlopen返回前执行完成。

## 内存
栈：通常在用户空间的最高地址处分配，通常有数MB大小。
堆：通常在栈的低地址方向，某些时候可能没有固定统一的存储区域，比栈大很多。
可执行文件映像：存储着可执行文件在内存里面的映像，由装载器负责分配空间
保留区：对禁止访问的内存区域的总称

栈保存了一个函数调用所需要的维护信息，一般称为堆栈帧或者活动记录。
堆栈帧包括：
* 函数的返回地址和参数
* 临时变量
* 保存的上下文：包括调用前后需要恢复的寄存器等等

i386中，一个函数的活动记录用ebp和esp两个寄存器划定范围，esp始终指向栈顶（移动esp相当于扩大/缩小栈空间）,ebp则指向函数活动记录的固定位置，称为帧指针。固定不变的ebp可以用来定位函数活动记录中的各个数据。ebp所直接指向的数据是调用之前的ebp值，这样函数返回时，可以进行恢复。

i386的函数总是这样调用：
* 把所有或者一部分参数压栈，没有入栈的使用特殊寄存器
* 把当前指令的下一条指令地址压栈
* 跳转执行

NOTE: gcc的-fomit-frame-pointer可以取消帧指针，可以多出一个ebp寄存器供使用，但是帧上寻址速度会变慢，无法准确定位调用轨迹。

调用惯例指定以下内容：
* 函数参数传递顺序和方式
* 栈的维护方式
* 名字修饰策略

返回值传递：
小value使用寄存器传递，大value由编译器传入一个隐藏参数，通过隐藏参数指定的空间获取返回值

Linux的两种堆空间分配的系统调用：
* brk ： 设定进程数据段的结束地址，可以扩大或缩小数据段
* mmap： 申请虚拟地址空间，可以映射到某个文件，或者直接作为匿名的堆空间

## 运行库

入口函数或者入口点是运行库的一部分，负责一个程序的初始化和结束：
* 操作系统创建进程后，把控制权交给程序入口
* 入口函数对运行库和程序运行环境进行初始化，堆、I/O、线程、全局变量构造等
* 调用main函数执行主体
* main结束后返回到入口函数，进行清理，全局变量析构、堆销毁、关闭I/O等

IO初始化主要包含几个工作：数据结构初始化；继承父进程文件描述符；初始化标准输入输出

c++全局对象的构造和析构并不是直接放在.init和.fini段里面的，而是把一个执行所有构造/析构的函数调用放在里面

传统CRT的多线程改造方法：
* TLS，比如errno的实现
* 加锁，将一些线程不安全的调用自动加锁
* 改进函数原型

如果希望在线程中使用一个全局变量，但是是线程私有的，就需要用到线程局部存储（TLS）。

## 系统调用与API

系统调用的两种形式：轮询/中断，中断是目前普遍的使用形式。

系统调用由0x80中断完成，**各个通用寄存器用于传递参数**，每个系统调用对应内核中的一个函数（_sys开头）

系统调用本身使用不便，各个操作系统之间不兼容，运行库作为系统调用和程序之间的一个抽象层可以提供的优点：使用简单、形式统一。

现代CPU有多种特权级别来执行指令，现代操作系统当中通常有两种特权级别：用户态和内核态。操作系统通过中断来从用户态切换到内核态。

中断由中断号和中断处理程序组成，内核中有一个中断向量表，向量表的第n项包含指向第n号中断的中断处理程序的指针。

一个Linux系统调用需要以下几步：
* 触发中断。Linux支持的系统调用最多有6个参数，分别使用6个寄存器传递
* 切换堆栈。将堆栈从用户栈切换到内核栈。从中断处理程序返回时，还要切换回来。
* 执行中断处理





